# 二、链表

## 1.1 链表定义

链表是一种物理[存储单元](https://baike.baidu.com/item/存储单元/8727749?fromModule=lemma_inlink)上非连续、非顺序的[存储结构](https://baike.baidu.com/item/存储结构/350782?fromModule=lemma_inlink)，[数据元素](https://baike.baidu.com/item/数据元素/715313?fromModule=lemma_inlink)的逻辑顺序是通过链表中的[指针](https://baike.baidu.com/item/指针/2878304?fromModule=lemma_inlink)链接次序实现的。

```
struct ListNode {
   int val; // 当前节点的值
   ListNode *next; // 下一个节点的指针
   ListNode() : val(0), next(nullptr) {} // 无参构造函数，将节点的值初始化为0
   ListNode(int x) : val(x), next(nullptr) {} //有参构造函数，节点的值初始化为x，下一个节点指向空节点
   ListNode(int x, ListNode *next) : val(x), next(next) {}//有参构造函数，指定节点的值为x，下一个节点指向next
 };
```

处理链表的技巧：通常使用哑节点，作为头节点的前驱节点，这样就不需要对头节点进行特殊判断。

## 1.2 题目：

### 19、删除链表的倒数第N个节点

给你一个链表，删除链表的倒数第`n`个节点，并返回链表的头节点。

##### 思路分析：

1. c++ 不提供链表长度的API，需要先遍历一遍，得到链表长度。
2. 为了不处理length=1的特殊情况，使用哑节点。
3. 当前指针从哑节点开始遍历，遍历次数：length - n + 1

##### 代码：

```
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        int length = 0;
        ListNode *p = head;
        while(p){
            length++;
            p = p->next;
        }

		// 哑节点，val设置为0，下一个节点指向头节点
        ListNode* dummy = new ListNode(0, head);
        ListNode* cur = dummy;

        for( int i = 1; i < length - n + 1; i++) {// 注意边界
            cur = cur->next;
        }
        
        cur->next = cur->next->next;
        
        //注意输出为dummy->next,而不是head，因为head也可能被删除
        ListNode* ans = dummy->next;
        delete dummy;
        return ans;

    }

```

### 21、合并两个有序链表

##### 问题描述：

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

![img](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)

##### 思路分析：

1. 首先判断两个链表都不为空，执行步骤2，若其中一个链表为空，返回另一个链表。
2. 需要4个指针cur1，next1，cur2，next2，分别指向每个链表的当前节点和下一个节点。
3. 分别遍历链表一和链表二，按照大小排序。

### 24、两两交换链表中的节点



给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

示例：

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

##### 疑问：

1. 是否需要判断奇偶

   不需要，循环退出的条件同时满足奇偶情况。

2. 循环退出的条件

   当前节点和邻居节点至少其中一个为空。

##### 思路分析：

1. 设置一个头节点的前驱节点
1. 定义当前指针cur，指向需要交换的节点对的前驱节点
1. 

##### 错误：

1. return 不应该是head，因为交换完后head指向的是第二个节点。

   在链表长度至少为2的情况下，先执行head=head->next

2. 交换节点p，q的时候没有考虑p的前驱节点连接的节点应该指向q

##### 代码：

```
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {

        ListNode *dummy = new ListNode(-1, head);                       //当前节点
        
        // cur指向当前要交换的节点对的前驱节点
        ListNode *cur = dummy;
        ListNode *p = nullptr;
        ListNode *q = nullptr;
        while(cur->next !=nullptr && cur->next->next != nullptr){

            p = cur->next;
            q = p->next;

            // 交换位置
            cur->next = q;
            p->next = q->next ; 
            q->next = p;

            // 遍历 
            cur = cur->next->next; 
        }

        // 返回结果
        ListNode* ans = dummy->next;
        delete dummy;
        return ans;

    }
};
```

### 61、旋转链表

##### 问题描述：

给定一个链表的头节点`head`，旋转链表，将链表每个节点向右移动`k`个位置。

示例：

![img](https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg)

##### 思路分析：

1. 计算链表长度，k/链表长度的余数就是移动次数n。
2. 将链表最后n个节点连接到链表开头。

### 82、删除排序链表中的重复元素Ⅱ



给定一个已排序的链表的头 `head` ， *删除原始链表中所有重复数字的节点，只留下不同的数字* 。返回 *已排序的链表* 。

示例：

![img](https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg)

```
输入：head = [1,2,3,3,4,4,5]
输出：[1,2,5]
```

##### 思路分析：

1. 设置哑节点，当前节点cur遍历链表。
2. 若 cur->next->val = cur->next->next->val，重复数字的节点的前驱节点pre = cur，
3. cur = cur->next, 遍历，直到cur.val != cur->next->val 或者cur->next == nullptr ，重复数字后继节点 suc = cur->next
4. pre->next=suc。
5. 若 cur->next != 空，cur指向下一个节点，同时跳转到步骤2。

##### 疑问：

1. 如何确保哑节点和头节点的值不一样

   不需要确保，当哑节点的下一节点不为空指针，当前指针先向右移动，再判断其是否和后继节点值重复。

##### 错误：

1. [1,2,3,3,4,4,5]输出[1,2,4,4,5]

   不需要前驱节点，cur即前驱节点。若cur->next->val == cur->next->next->val

2. `while(cur->next->val == cur->next->next->val && cur->next != nullptr && cur->next->next != nullptr )`报错使用了空指针

   while语句中的判断顺序出错。解决方法：将判断指针是否为空的语句放在前面

##### 代码：

```
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode *dummy = new ListNode(-1, head);
        ListNode *cur = dummy;          //当前指针，用于遍历链表
        ListNode *pre = nullptr;        //pre指向第一个值重复节点的前驱节点      

        while(cur->next != nullptr && cur->next->next != nullptr){
            
            // 发现值重复的节点
            if(cur->next->val == cur->next->next->val){
                pre = cur;          
                //cur遍历，找到最后一个值重复节点
                while(cur->next != nullptr && cur->next->next != nullptr && cur->next->val == cur->next->next->val){
                    cur = cur->next;
                }

                //删除节点
                pre ->next = cur->next->next;
                cur = dummy;
            }

            else{
                cur = cur->next;
            }
            
        }

        return dummy->next;
    }
```



### 83、删除排序链表中的重复元素

给定一个已排序的链表的头 `head` ， *删除所有重复的元素，使每个元素只出现一次* 。返回 *已排序的链表* 。

![img](https://assets.leetcode.com/uploads/2021/01/04/list1.jpg)

```
输入：head = [1,1,2]
输出：[1,2]
```

##### 思路分析：

1. 设置哑节点
2. 若找到重复节点，cur遍历到第一个重复节点的前驱节点，pre=cur，否则进入第五步。
3. 当cur->next->val == cur->next->next->val ,cur = cur->next;  循环结束，cur指向倒数第二个重复节点。
4. pre = cur->next->next。
5. cur=cur->next

### 86、分隔链表

给你一个链表的头节点 `head` 和一个特定值 `x` ，请你对链表进行分隔，使得所有 **小于** `x` 的节点都出现在 **大于或等于** `x` 的节点之前。

你应当 **保留** 两个分区中每个节点的初始相对位置。

![img](https://assets.leetcode.com/uploads/2021/01/04/partition.jpg)

```
输入：head = [1,4,3,2,5,2], x = 3
输出：[1,2,2,4,3,5]
```

##### 思路分析：

1. 维护一个保持初始相对位置的小于x的链表small和一个大于x的链表large。
2. cur->val 小于x时，small->next  = cur; smal = smal->next
3. cur->val 大于x时，large->next = cur; large = large->next

##### 错误：

1. 只维护一个小于x的链表，过于复杂

   正确做法：用两个哑节点，分别维护小于x的链表和大于x的链表。最后合并两个链表。

2. 维护大于x的链表时，最后未让其尾节点的下一节点指向空。

##### 代码：

```
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode *dummy_small = new ListNode(0);
        ListNode *dummy_large = new ListNode(0);

        ListNode *end_small = dummy_small;
        ListNode *end_large = dummy_large;

        while(head){
            if(head->val < x){
                end_small->next = head;
                end_small = end_small->next;
            }

            else{
                end_large->next = head;
                end_large = end_large->next;
            }

            head = head->next;
        }

        end_large->next = nullptr;
        end_small->next = dummy_large->next;
        return dummy_small->next;
    }
};
```

### 92、反转链表Ⅱ TODO

给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 

![img](https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg)

```
输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
```

##### 思路分析：

1. 头插法

### 109、有序链表转换二叉搜索树

给定一个单链表的头节点`head`，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。

本题中，一个高度平衡的二叉树是指一个二叉树每个节点的左右两个子树的高度差不超过1。

##### 二叉树的定义

```
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};
```

##### 思路分析：

1. 第一步，确定根节点。找出链表元素的中位数作为根节点的值。
2. 

# 

