# 一、概述

##### 排序的分类：

- ##### 内部排序:

  - 数据记录在内存中进行排序
    - 内存
      - RAM


- 外部排序:

  - 排序的数据很大，不能一次容纳全部的排序记录，过程中需要访问外存

    - 外存

      - 硬盘驱动器（HDD）

      - 固态硬盘（SSD）

      - 网络存储（NAS）：通过网络连接，提供数据存储和访问服务

      - 等等

    - 算法
      - 外部并归排序（External Merge Sort）
      - 外部桶排序（External Bucket Sort）

## 十大(内部)排序算法：

![sort](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/sort.png)

### 1、冒泡排序

##### 示意图：

![bubbleSort](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/bubbleSort.gif)

##### 步骤：

1. 比较相邻元素，若前者比后者大，就交换顺序
2. 第一趟下来，最大的会放在最后
3. 重复上述步骤，除了最后一个元素
4. 每次对越来越少的数据进行上述步骤，直到排序完成

### 2、选择排序

##### 示意图：

![selectionSort](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/selectionSort.gif)

##### 步骤：

1. 在未排序的序列中找到最大（小）元素，放在未排序序列的最前面
2. 从剩余未排序序列中继续寻找最大（小）元素
3. 重复第二步，直到所有元素排序完成

### 3、插入排序

##### 流程图：

![insertionSort](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/insertionSort.gif)

##### 步骤：

1. 将第一个元素视为已排序序列，剩余元素为未排序序列
2. 对未排序序列的第一个元素与已排序序列的每一个值比较，插入适当位置。
3. 重复步骤2，直到所有元素都排序完成

### 4、希尔排序

### 5、归并排序

### 6、快速排序

### 7、堆排序

### 8、计数排序

### 9、桶排序

### 10、基数排序

## 问题：

##### 1、外部排序具体是怎么使用外存

##### 2、如何评价算法的稳定性

## 参考资料

https://www.runoob.com/w3cnote/ten-sorting-algorithm.html

# 二、题目：

## 15、三数之和

给你一个整数数组`nums`，判断是否存在三元组`[nums[i], nums[j], nums[k]]`满足`i != j、i != k`且`j != k`，同时还满足`nums[i] + nums[j] + nums[k]==0`。请返回所有和为`0`且不重复的三元组。

示例1：

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

示例2：

```
输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。
```

示例3：

```
输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 。
```

提示

- `3 <= nums.length <= 3000`
- `-10⁵ <= nums[i] <= 10⁵`

##### 思路分析：

难点在于如何去除重复解

1. 对数组进行排序，得到一个递增的数组。
2. 遍历排序后的数组：
   - 若`nums[i] > 0`：因为已经排序好，所以后面不可能有三个数加和等于0，直接返回结果。
   - 对于重复元素：跳过，避免出现重复解。
   - 令左指针`L = i + 1`，右指针`R = n - 1`，当`L < R`时
     - 若`nums[i] + nums[L] + nums[R] == 0`,加入解中，并**同时**将L和R向下一位移动，寻找新的解。
     - 若和大于0，说明`nums[R]`太大，R左移
     - 若和小于0，说明`nums[L]`太小，L右移

##### 问题：

1. 如何遍历数组？

   答：应考虑使用双指针，`i`指向当前指针，`L`从`i+1`开始遍历，`R`从数组末尾开始遍历。

2. 如何存储答案？题目要求一个一个输出三元组还是将所有三元组一次性输出。

   答：函数的返回类型为`vector<vector<int>>`,所以为后者。

3. C++如何对容器中的元素进行排序

   答：使用`<algorithm>`头文件中的`std::sort`函数。eg：

   ```c++
   #include <algorithm>
   int main(){
   	std::vector<int> vec = {4, 2, 8, 1, 5};
   	std::sort(vec.begin(), vec.end());
   	......
   }
   ```


##### 代码：

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        std::sort(nums.begin(), nums.end()); // 排序
        
        vector<vector<int>> res;

        for(int i = 0; i < nums.size(); i++){
        
            //跳过重复元素,重点，必须加上i>0
            if(i>0 && nums[i] == nums[i-1] ){
                continue;
            }

            int L = i + 1;
            int R = nums.size() - 1;
            while(L < R){
                if(nums[i] + nums[L] + nums[R] == 0){
                    res.push_back({nums[i], nums[L], nums[R]});

                    // 同时移动左右指针，且跳过相同元素
                    while(L < R && nums[L] == nums[L + 1]){
                        L++;
                    }
                    while(L < R && nums[R] == nums[R - 1]){
                        R--;
                    }   
                    // 当前元素和下个元素不相等后，移到下个元素
                    L++;
                    R--;

                }else if(nums[i] + nums[L] + nums[R] > 0){
                    R--;
                }else
                    L++;
            }
        }

        return res;

    }
};
```

需要注意指针移动后所在位置

## 16、最接近的三数之和

给你一个长度为 `n` 的整数数组 `nums` 和 一个目标值 `target`。请你从 `nums` 中选出三个整数，使它们的和与 `target` 最接近。

返回这三个数的和。

假定每组输入只存在恰好一个解。

**示例 1：**

```
输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
```

**示例 2：**

```
输入：nums = [0,0,0], target = 1
输出：0
```

**提示：**

- `3 <= nums.length <= 1000`
- `-1000 <= nums[i] <= 1000`
- `-104 <= target <= 104`

##### 思路分析1（错误思路）：

1. 对数组进行排序
2. 使用大小为3的滑动窗口，右移遍历数组
3. 判特，若数组大小为3，直接返回
4. 记录移动之前的和为sum_before，移动之后的和为sum_now
   - `sum_now > target`,则选择`sum_before`和`sum_now`中与`target`相差更小的作为res返回。
   - `sum_now < target`且`sum_before < target`则滑动窗口持续右移，直到到达末尾或者`sum_now > target`

**错误：**答案不一定在固定窗口中

##### 思路分析2：

1. 对数组进行排序
2. `sub = nums[0] + nums[1] + nums[2] - target` 的绝对值
3. 下标i遍历数组，左指针`L = i + 1`，右指针`R = size - 1`
   - 若 `nums[i] + nums[L] + nums[R] == target` , 返回target
   - 若`nums[i] + nums[L] + nums[R] < target`，`sub` 为`nums[i] + nums[L] + nums[R] - target`与`sub`当前值中绝对值更小的那个,L右移，且跳过重复元素
   - 若`nums[i] + nums[L] + nums[R] > target` ，`sub` 为`nums[i] + nums[L] + nums[R] - target`与`sub`当前值中绝对值更小的那个，R左移，且跳过重复元素
4. 返回`target+sub`

##### 问题：

1. 滑动窗口如何表示？

   答：使用双指针，分别代表左端和右端。

2. 如何保存上一次的结果？

   答：使用下标，`sum_before = nums[i-1] + nums[i] + nums[i+1]`

##### 代码：

```c++
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());

        int sub = nums[0] + nums[1] + nums[2] - target;

        for(int i = 0; i < nums.size()-2; i++){
            int L = i + 1;
            int R = nums.size()-1;

            while(L < R){
                int sum = nums[i] + nums[L] + nums[R];
                sub = abs(sum - target) < abs(sub) ? (sum - target) : sub;

                if(sub == 0){
                    return target;
                }
                else if(sum < target){ //注意，这里不能使用sub < 0, 因为sub不一定是当前的
                    while(L < R && nums[L] == nums[L+1]){
                        L++;
                    }
                    L++;  
                }
                else{
                    while(L < R && nums[R] == nums[R-1]){
                        R--;
                    }
                    R--;
                }
            }
            
        }
        return sub + target;
    }
};
```



## 18、四数之和  to do

给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：

- `0 <= a, b, c, d < n`
- `a`、`b`、`c` 和 `d` **互不相同**
- `nums[a] + nums[b] + nums[c] + nums[d] == target`

你可以按 **任意顺序** 返回答案 。

**示例 1：**

```
输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```

**示例 2：**

```
输入：nums = [2,2,2,2,2], target = 8
输出：[[2,2,2,2]]
```

**提示：**

- `1 <= nums.length <= 200`
- `-109 <= nums[i] <= 109`
- `-109 <= target <= 109`

##### 思路分析

难点：如何去除重复答案

1. 对数组进行排序
2. 四指针abcd，指针b从数组第二位遍历到倒数第三位，跳过重复元素
   - a 从0遍历到b-1，且跳过重复元素
     -  `c = b + 1, d = size - 1`
        - 若`nums[a] + nums[b] + nums[c] + nums[d] == 0`, 加入解中，同时移动c，d，`c = c +1,d = d -1`,且跳过重复元素。
        - 若`nums[a] + nums[b] + nums[c] +nums[d] < 0`, 则右移c，且跳过重复元素
        - 若`nums[a] + nums[b] + nums[c] + nums[d] > 0`,则左移d，跳过重复元素 

##### 错误



##### 问题

1. 如何遍历设置指针abcd

   遍历`a`从数组头部开始，`c=b+1，d=size-1`，b从数组第二位遍历到倒数第三位。

## 49、字母异位词分组 to do 

给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。

**示例 1:**

```
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
```

**示例 2:**

```
输入: strs = [""]
输出: [[""]]
```

**示例 3:**

```
输入: strs = ["a"]
输出: [["a"]]
```

**提示：**

- `1 <= strs.length <= 104`
- `0 <= strs[i].length <= 100`
- `strs[i]` 仅包含小写字母

##### 问题：

1. 如何对字母进行排序

##### 思路分析1：

1. 遍历strs，对strs[i]中的字母进行排序
2. 对strs进行排序，但是无法知道原来的单词顺序

##### 思路1改进：

1. 将strs[i]拷贝一份

2. 对每一个单词进行排序，使用hash表存储排序后相等的单词。

   如：“ant” ： “nat” ，“tan”；“aet”：“ate”，“eat”，“tea”

##### 相关知识：

- 字符串的拷贝：

  1. 使用赋值运算符： `copy_str = original_str`
  2. 使用字符串的构造函数：`string = copy_str(original)`
  3. 使用`assign`函数：`copy_str.assign(original)`
  4. 使用`substr`函数：`copy_str = original_str.substr(0)`
  5. 使用`+`运算符：`copy_str = original + ""`

- hash表

  是一种数据结构，用于实现**关联数组(Associative Array)**或**映射(Map)**这样的抽象数据类型。通过将关键字映射到表中的一个位置来实现高效的数据检索。以下是哈希表的关键特性和原理。

  1. 哈希函数。

     哈希函数是哈希表的核心。该函数接受一个关键字作为输入，并返回一个索引或桶的位置。

  2. 冲突处理

     哈希函数的输出空间远远小于输入空间，不同关键字可能映射到相同的位置。

##### 代码：

```C++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        vector<vector<string>> res;
        unordered_map<string, vector<string>> u_mapRes;
        for (auto& str : strs) {
            //对副本进行排序
            string key(str);				// 使用字符串的构造函数进行字符串复制
            sort(key.begin(), key.end());	// 排序
            //存到hash表中
            u_mapRes[key].push_back(str);
        }
        for (auto& pair : u_mapRes) {
            res.push_back(pair.second);
        }
        return res;
    }
};
```

## 56、合并区间

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。

**示例 1：**

```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**示例 2：**

```
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

#####  思路分析

1. 按照$start_i$的大小对$intervals[i]$进行排序
2. 判空，若intervals为空，返回空
3. `i`从0开始，遍历到intervals[i]，当前区间`interval_now.start = intervals[i].start`
   - 若`i = intervals.size() - 1`  ，则`interval_now.end = interval[i].end`,跳出遍历
   - 若`intervals[i].end < intervals[i+1].start`，则`interval_now.end = interval[i+1].end `
   - 若`intervals[i].end > intervals[i+1].start`，则 进入下一轮遍历。 

##### 代码实现：

