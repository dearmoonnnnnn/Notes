# 视频地址：

- c++11新特性：

  https://www.youtube.com/watch?v=TJIb9TGfDIw&list=PL-X74YXt4LVYo_bk-jHMV5T3LHRYRbZoH

  https://www.youtube.com/watch?v=8jO1e6l7IGc&list=PLH_SiDrNHIUTzLKsNW-ZSDX4Oj3uECg64

- c++内存管理机制

  https://www.youtube.com/watch?v=0ymWCS1E8t4&list=PLH_SiDrNHIUTQM_ZPqI4b8as35_5rJWjS

- std标准库与泛型编程

  https://www.youtube.com/watch?v=SLcWLz1mgow&list=PLH_SiDrNHIUS8wBdEIxoAXag5r2Ju-lq_

- **面向对象高级高级开发(上)**

  https://www.youtube.com/watch?v=ETkCNquiAiw&list=PL1S6aIjFDLHTsycQuMgdBVC3fEwzxsbT1

- C++ start up 揭秘：C++程序的生前死后

  https://www.youtube.com/watch?v=_b5yzeXwMfY&list=PLH_SiDrNHIURCCENYhmaF3SVbARiom7Oc

# 零、

## 问题

##### 1、引用和指针的区别

C++中引用和指针都是用于间接访问内存中的数据,但是它们有以下几个主要区别:

1. **语法**:
   - 引用使用&操作符来声明,如 `int& r = i;`
   - 指针使用*操作符来声明,如 `int* p = &i;`

2. **初始化**:
   - 引用在声明的同时必须被初始化,并且以后不能被改为引用其他数据。
   - 指针可以在任何时候指向新的数据。

3. **内存占用**:
   - 引用本身不占用内存,它只是已有变量数据的一个别名。
   - 指针本身占用内存来存储所指向的地址。

4. **操作**:
   - 对引用进行操作时,就好像直接操作了所引用的变量。
   - 对指针进行操作时,需要先使用解引用操作符*来访问所指向的值。

5. **空指针**:
   - 引用必须绑定到一个确定的变量,不能是一个空引用。
   - 指针可以为空指针,表示不指向任何数据。

6. **自增操作**:
   - 对引用执行自增(&++)操作是非法的。
   - 对指针执行自增(++)操作是合法的,将使指针指向下一个内存位置。

7. **作为函数参数**:
   - 将引用作为函数参数可以直接修改实参的值。
   - 将指针作为函数参数需要解引用才能修改所指向的值。

总的来说,引用提供了一种直接访问变量的方式,而指针则提供了一种间接访问内存地址的方式。引用的语法更简单,但指针更加灵活。在大多数情况下,优先使用引用可以避免一些指针相关的错误。

##### 2、inline作为函数的返回类型是什么情况？

在C++中,`inline`不能作为函数的返回类型。`inline`是一个关键字,用于指示编译器尽可能将函数的代码嵌入调用点,而不是作为单独的函数调用。**它是一个函数限定符**,可以应用于函数定义或函数声明。

`inline`关键字的作用是:

1. **函数定义时**:将此函数定义为内联函数,编译器会尝试在调用点展开函数代码,而不是进行普通的函数调用。这可以减少函数调用的开销,但可能会增加目标代码的大小。

2. **函数声明时**:声明此函数可能在其他编译单元中定义为内联函数。这为编译器提供了内联函数的线索,但不强制进行内联。

正确的语法是在函数返回类型之前使用`inline`关键字,例如:

```cpp
inline int add(int x, int y) {
    return x + y;
}
```

或者

```cpp
inline int add(int x, int y);
```

但是不能将`inline`用作返回类型,例如:

```cpp
inline add(int x, int y) { // 错误!inline不能作为返回类型
    return x + y;
}
```

总的来说,`inline`关键字用于指导编译器执行函数内联,但不能用作函数的返回类型。

# 二、头文件与类的声明

## 1、头文件中的防卫式声明

![image-20240317011302793](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240317011302793.png)

##### 动机：

当工程很大的时候，我们可能会重复`include`同一个头文件。防卫式声明使得头文件被多次被`include`时，只有第一次生效。

##### 具体语法

- `#ifndef __COMPLEX__`

  如果之前如果没有定义过 `COMPLEX`

- `#define __COMPLEX__`

  那么就定义`__COMPLEX__`

## 2、class的声明

![image-20240317012616822](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240317012616822.png)

##### 前置声明（forward declarations）

##### 类声明（class declarations）

- class head
- class body

##### 类定义（class definitoin） 

##### 举例：复数的声明

![image-20240317013503382](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240317013503382.png)

## 3、模板

##### 动机：

声明class的时候不确定变量的类型，可以先用模板

##### 示例：

![image-20240317014026388](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240317014026388.png)

声明复数类的时候，不确定实部和虚部的类型，使用模板。

# 三、构造函数

## 1、内联函数

![image-20240317013503382](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240317013503382.png)

- 函数可以在class body中定义，称为内联函数

  ```cpp
  double real () const { return re; }
  double imag () const { return im; }
  ```

  - 可以将所有函数的定义都写在类的声明中，但是最终是否为内联函数，由编译器决定。太复杂的函数不能称为内联函数。

- 也可以只在这声明，在body之外定义

  ```cpp
  complex& operator += (const complex&) ;
  ```

​	

## 2、访问级别

##### public

公开可见

函数，如果要被外界调用，则放在public

##### private

私人可见，创建的对象不能直接调用相关的参数

一般是数据变量

## 3、构造函数

![image-20240317174921085](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240317174921085.png)

- 没有返回类型
- 与类名同名
- 赋值方式
  - 推荐使用初始列赋值，这种写法只有构造函数有。
  - 也可以在函数体里赋值，但是不推荐。即图片右上角的方法。

##### 析构函数

不带指针的类大部分不用写

## 4、重载 overloading

一个以上的相同名称的函数

![image-20240317180008848](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240317180008848.png)

- ```cpp
  double real () const {return re}
  ```

  返回实部

- ```cpp
  double real (double r) { re = r;}
  ```

  给实部赋值

- real函数编译后，编译器会根据参数数量、参数的类型，编码出不同的名称

##### 不能使用重载的情况

图中黄色部分，不能使用

当我们执行

```cpp
complex c1；
```

或

```cpp
complex c2();
```

两个构造函数都有默认值，都可以被调用，编译器不知道调用哪个，所以不能使用黄色部分

# 四、参数传递与返回值

## 1、将构造函数放在private中：Singleton设计模式

![image-20240318130504235](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240318130504235.png)

##### 动机：

Singleton 模式保证一个类只有一个实例存在。

## 2、常量成员函数

![image-20240318131444117](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240318131444117.png)

##### 动机：

不改变数据的成员函数，要使用`const`。例如：只读取相关的数据。

##### const出现的位置：

- 成员函数

  出现在小括号的后面，大括号的前面

- 对象或者变量

  出现在前面，表明对象或者变量的内容不可改变

##### 该使用const但没使用后果：

```cpp
double real () { return re; }
```

```cpp
{
	const complex c1(2,1);
	cout << c1.real();
}
```

c1为静态对象，数据不可更改，但c1.real()没加const，编译器认为该函数可以改变数据，因此调用该函数会报错。

## 3、参数传递：pass by value vs. pass by reference (to const)

![image-20240318133856394](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240318133856394.png)

##### 传递值：

直接将值打包传递到函数的堆栈中，占用的字节可能会很大，不推荐

##### 传递引用：

只传递数据的地址，占用的字节就是地址的大小，速度很快

函数中的参数尽量都使用这种写法。

##### 传递静态引用：

传递引用，函数对于参数的修改会影响到原来的数据。

如果不希望函数修改参数的值，传递静态引用

## 4、返回值传递：pass by value vs. pass by reference (to const)

在可以的情况下，尽量使用引用传递。

##### 不可以使用引用传递返回值的情况：

当返回值是函数中创建的变量时，不能传递该变量的引用作为返回值。

因为函数结束后，该变量会消失

## 5、友元（friend）函数

![image-20240318162505486](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240318162505486.png)

##### 动机：

private的变量被封装起来，不能直接读取。但是有一些函数需要直接读取数据，就用友元函数。

##### 示例：

图片下方，由于是友元函数，可以直接使用对象被封装起来的变量：`ths->re`和`ths->im`

## 6、相同class的各个objects互为友元(friends)

![image-20240318164313481](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240318164313481.png)

两个对象`c1`和`c2`从同一个class实例化而来，`c2`中的函数可以直接访问`c1`中封装的数据。

原因：相同class的各个objects互为友元(friends)。

# 小结：

1、数据放在private中

2、参数尽可能用引用传递，是否要加const看情况

3、返回值尽可能用引用传递

4、类的body中的函数，应该加const就加

5、构造函数尽量使用**成员初始化列表**

# 五、操作符重载与临时对象

## 1、操作符重载——成员函数

操作符也是一种函数，C++允许用户重载

![image-20240319102600752](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240319102600752.png)

##### this

- 代表当前对象的地址。它是一个指向当前对象的指针常量。
- 存在于每一个**非静态成员函数**中，可以在函数体里面使用，但是不能在参数中写出来，显示地作为参数传递给成员函数。(途中写出来只是为了方便理解)
- 静态成员函数不能使用this

## 2、return by reference 语法分析

![image-20240319104540756](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240319104540756.png)

传递者无需知道接受者是以**引用**形式接收。PS：接收端也可以通过by value方式接收。

- 图中最上方，this是一个指针，返回值为`*this`，为指针指向的对象，但是声明中的返回值是引用`complex&`。这也是正确的。

##### +=操作符的返回类型

为了让 `c3 += c2 += c1`合法，返回类型不能为void 

# 小结：类的声明部分结束，类的定义部分开始

![image-20240319111422949](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240319111422949.png)

上述所有内容均在类的声明中，即1中。下面的内容为类的定义，即2中。

2中有两种函数：

- 成员函数和非成员函数

## 3、操作符重载——非成员函数

![image-20240319111931426](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240319111931426.png)

## 4、临时对象 temp object

![image-20240319113503278](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240319113503278.png)

##### 使用`typename()`形式创建临时对象

- 途中三个函数return的值，右边标黄的部分，均为临时对象。
  - return 临时对象，不能使用引用返回。
- 临时对象的生命周期：下一行就消失。

## 5、<< 操作符的重载

![image-20240319121254508](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240319121254508.png)

##### 不能写为成员函数进行重载，只能写为全局函数。

原因：

其左操作数（即`cout`）必须是输出流对象(如std::ostream),而不是用户定义的类对象。

##### 返回类型不能改为void

若改为void，无法连串输出

# 小结：设计一个class要考虑的因素

![image-20240319121555390](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240319121555390.png)

1. 构造函数要使用**成员初始化列表**
2. 函数要考虑能否使用静态函数，尽量使用
3. 参数的传递，尽量考虑引用，同时考虑是否要加const
4. 参数的返回，尽量考虑引用
5. 数据尽量放在private，函数尽量放在public
