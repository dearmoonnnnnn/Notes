# 视频地址：

- c++11新特性：

  https://www.youtube.com/watch?v=TJIb9TGfDIw&list=PL-X74YXt4LVYo_bk-jHMV5T3LHRYRbZoH

  https://www.youtube.com/watch?v=8jO1e6l7IGc&list=PLH_SiDrNHIUTzLKsNW-ZSDX4Oj3uECg64

- c++内存管理机制

  https://www.youtube.com/watch?v=0ymWCS1E8t4&list=PLH_SiDrNHIUTQM_ZPqI4b8as35_5rJWjS

- std标准库与泛型编程

  https://www.youtube.com/watch?v=SLcWLz1mgow&list=PLH_SiDrNHIUS8wBdEIxoAXag5r2Ju-lq_

- **面向对象高级高级开发(上)**

  https://www.youtube.com/watch?v=ETkCNquiAiw&list=PL1S6aIjFDLHTsycQuMgdBVC3fEwzxsbT1

- C++ start up 揭秘：C++程序的生前死后

  https://www.youtube.com/watch?v=_b5yzeXwMfY&list=PLH_SiDrNHIURCCENYhmaF3SVbARiom7Oc

# 二、头文件与类的声明

## 1、头文件中的防卫式声明

![image-20240317011302793](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240317011302793.png)

##### 动机：

当工程很大的时候，我们可能会重复`include`同一个头文件。防卫式声明使得头文件被多次被`include`时，只有第一次生效。

##### 具体语法

- `#ifndef __COMPLEX__`

  如果之前如果没有定义过 `COMPLEX`

- `#define __COMPLEX__`

  那么就定义`__COMPLEX__`

## 2、class的声明

![image-20240317012616822](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240317012616822.png)

##### 前置声明（forward declarations）

##### 类声明（class declarations）

- class head
- class body

##### 类定义（class definitoin） 

##### 举例：复数的声明

![image-20240317013503382](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240317013503382.png)

## 3、模板

##### 动机：

声明class的时候不确定变量的类型，可以先用模板

##### 示例：

![image-20240317014026388](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240317014026388.png)

声明复数类的时候，不确定实部和虚部的类型，使用模板。

# 三、构造函数

## 1、内联函数

![image-20240317013503382](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240317013503382.png)

- 函数可以在class body中定义，称为内联函数

  ```cpp
  double real () const { return re; }
  double imag () const { return im; }
  ```

  - 可以将所有函数的定义都写在类的声明中，但是最终是否为内联函数，由编译器决定。太复杂的函数不能称为内联函数。

- 也可以只在这声明，在body之外定义

  ```cpp
  complex& operator += (const complex&) ;
  ```

​	

## 2、访问级别

##### public

公开可见

函数，如果要被外界调用，则放在public

##### private

私人可见，创建的对象不能直接调用相关的参数

一般是数据变量

## 3、构造函数

![image-20240317174921085](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240317174921085.png)

- 没有返回类型
- 与类名同名
- 赋值方式
  - 推荐使用初始列赋值，这种写法只有构造函数有。
  - 也可以在函数体里赋值，但是不推荐。即图片右上角的方法。

##### 析构函数

不带指针的类大部分不用写

## 4、重载 overloading

一个以上的相同名称的函数

![image-20240317180008848](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240317180008848.png)

- ```cpp
  double real () const {return re}
  ```

  返回实部

- ```cpp
  double real (double r) { re = r;}
  ```

  给实部赋值

- real函数编译后，编译器会根据参数数量、参数的类型，编码出不同的名称

##### 不能使用重载的情况

图中黄色部分，不能使用

当我们执行

```cpp
complex c1；
```

或

```cpp
complex c2();
```

两个构造函数都有默认值，都可以被调用，编译器不知道调用哪个，所以不能使用黄色部分
