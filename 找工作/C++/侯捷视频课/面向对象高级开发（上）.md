# 视频地址：

- c++11新特性：

  https://www.youtube.com/watch?v=TJIb9TGfDIw&list=PL-X74YXt4LVYo_bk-jHMV5T3LHRYRbZoH

  https://www.youtube.com/watch?v=8jO1e6l7IGc&list=PLH_SiDrNHIUTzLKsNW-ZSDX4Oj3uECg64

- c++内存管理机制

  https://www.youtube.com/watch?v=0ymWCS1E8t4&list=PLH_SiDrNHIUTQM_ZPqI4b8as35_5rJWjS

- std标准库与泛型编程

  https://www.youtube.com/watch?v=SLcWLz1mgow&list=PLH_SiDrNHIUS8wBdEIxoAXag5r2Ju-lq_

- **面向对象高级高级开发(上)**

  https://www.youtube.com/watch?v=ETkCNquiAiw&list=PL1S6aIjFDLHTsycQuMgdBVC3fEwzxsbT1

- C++ start up 揭秘：C++程序的生前死后

  https://www.youtube.com/watch?v=_b5yzeXwMfY&list=PLH_SiDrNHIURCCENYhmaF3SVbARiom7Oc

# 零、

## 问题

##### 1、引用和指针的区别

C++中引用和指针都是用于间接访问内存中的数据,但是它们有以下几个主要区别:

1. **语法**:
   - 引用使用&操作符来声明,如 `int& r = i;`
   - 指针使用*操作符来声明,如 `int* p = &i;`

2. **初始化**:
   - 引用在声明的同时必须被初始化,并且以后不能被改为引用其他数据。
   - 指针可以在任何时候指向新的数据。

3. **内存占用**:
   - 引用本身不占用内存,它只是已有变量数据的一个别名。
   - 指针本身占用内存来存储所指向的地址。

4. **操作**:
   - 对引用进行操作时,就好像直接操作了所引用的变量。
   - 对指针进行操作时,需要先使用解引用操作符*来访问所指向的值。

5. **空指针**:
   - 引用必须绑定到一个确定的变量,不能是一个空引用。
   - 指针可以为空指针,表示不指向任何数据。

6. **自增操作**:
   - 对引用执行自增(&++)操作是非法的。
   - 对指针执行自增(++)操作是合法的,将使指针指向下一个内存位置。

7. **作为函数参数**:
   - 将引用作为函数参数可以直接修改实参的值。
   - 将指针作为函数参数需要解引用才能修改所指向的值。

总的来说,引用提供了一种直接访问变量的方式,而指针则提供了一种间接访问内存地址的方式。引用的语法更简单,但指针更加灵活。在大多数情况下,优先使用引用可以避免一些指针相关的错误。

##### 2、inline作为函数的返回类型是什么情况？

在C++中,`inline`不能作为函数的返回类型。`inline`是一个关键字,用于指示编译器尽可能将函数的代码嵌入调用点,而不是作为单独的函数调用。**它是一个函数限定符**,可以应用于函数定义或函数声明。

`inline`关键字的作用是:

1. **函数定义时**:将此函数定义为内联函数,编译器会尝试在调用点展开函数代码,而不是进行普通的函数调用。这可以减少函数调用的开销,但可能会增加目标代码的大小。

2. **函数声明时**:声明此函数可能在其他编译单元中定义为内联函数。这为编译器提供了内联函数的线索,但不强制进行内联。

正确的语法是在函数返回类型之前使用`inline`关键字,例如:

```cpp
inline int add(int x, int y) {
    return x + y;
}
```

或者

```cpp
inline int add(int x, int y);
```

但是不能将`inline`用作返回类型,例如:

```cpp
inline add(int x, int y) { // 错误!inline不能作为返回类型
    return x + y;
}
```

总的来说,`inline`关键字用于指导编译器执行函数内联,但不能用作函数的返回类型。

##### 3、char* str为什么可以表示字符串

在C++中，字符串被表示为字符数组，以空字符`\0`结尾，因此可以用于一个字符指针指向字符串的第一个字符，通过遍历字符数组来访问整个字符串。

## 概念

##### 成员初值列/成员初始化列表

# 二、头文件与类的声明

## 1、头文件中的防卫式声明

![image-20240317011302793](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240317011302793.png)

##### 动机：

当工程很大的时候，我们可能会重复`include`同一个头文件。防卫式声明使得头文件被多次被`include`时，只有第一次生效。

##### 具体语法

- `#ifndef __COMPLEX__`

  如果之前如果没有定义过 `__COMPLEX__`

- `#define __COMPLEX__`

  那么就定义`__COMPLEX__`

## 2、class的声明

![image-20240317012616822](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240317012616822.png)

##### 前置声明（forward declarations）

##### 类声明（class declarations）

- class head
- class body

##### 类定义（class definitoin） 

##### 举例：复数的声明

![image-20240317013503382](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240317013503382.png)

## 3、模板

##### 动机：

声明class的时候不确定变量的类型，可以先用模板

##### 示例：

![image-20240317014026388](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240317014026388.png)

声明复数类的时候，不确定实部和虚部的类型，使用模板。

# 三、构造函数

## 1、内联函数

![image-20240317013503382](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240317013503382.png)

- 函数可以在class body中定义，称为内联函数

  ```cpp
  double real () const { return re; }
  double imag () const { return im; }
  ```

  - 可以将所有函数的定义都写在类的声明中，但是最终是否为内联函数，由编译器决定。太复杂的函数不能称为内联函数。

- 也可以只在这声明，在body之外定义

  ```cpp
  complex& operator += (const complex&) ;
  ```

​	

## 2、访问级别

##### public

公开可见

函数，如果要被外界调用，则放在public

##### private

私人可见，创建的对象不能直接调用相关的参数

一般是数据变量

## 3、构造函数

![image-20240317174921085](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240317174921085.png)

- 没有返回类型
- 与类名同名
- 赋值方式
  - 推荐使用初始列赋值，这种写法只有构造函数有。
  - 也可以在函数体里赋值，但是不推荐。即图片右上角的方法。

##### 析构函数

不带指针的类大部分不用写

## 4、重载 overloading

一个以上的相同名称的函数

![image-20240317180008848](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240317180008848.png)

- ```cpp
  double real () const {return re}
  ```

  返回实部

- ```cpp
  double real (double r) { re = r;}
  ```

  给实部赋值

- real函数编译后，编译器会根据参数数量、参数的类型，编码出不同的名称

##### 不能使用重载的情况

图中黄色部分，不能使用

当我们执行

```cpp
complex c1；
```

或

```cpp
complex c2();
```

两个构造函数都有默认值，都可以被调用，编译器不知道调用哪个，所以不能使用黄色部分

# 四、参数传递与返回值

## 1、将构造函数放在private中：Singleton设计模式

![image-20240318130504235](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240318130504235.png)

##### 动机：

Singleton 模式保证一个类只有一个实例存在。

## 2、常量成员函数

![image-20240318131444117](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240318131444117.png)

##### 动机：

不改变数据的成员函数，要使用`const`。例如：只读取相关的数据。

##### const出现的位置：

- 成员函数

  出现在小括号的后面，大括号的前面

- 对象或者变量

  出现在前面，表明对象或者变量的内容不可改变

##### 该使用const但没使用后果：

```cpp
double real () { return re; }
```

```cpp
{
	const complex c1(2,1);
	cout << c1.real();
}
```

c1为静态对象，数据不可更改，但c1.real()没加const，编译器认为该函数可以改变数据，因此调用该函数会报错。

## 3、参数传递：pass by value vs. pass by reference (to const)

![image-20240318133856394](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240318133856394.png)

##### 传递值：

直接将值打包传递到函数的堆栈中，占用的字节可能会很大，不推荐

##### 传递引用：

只传递数据的地址，占用的字节就是地址的大小，速度很快

函数中的参数尽量都使用这种写法。

##### 传递静态引用：

传递引用，函数对于参数的修改会影响到原来的数据。

如果不希望函数修改参数的值，传递静态引用

## 4、返回值传递：pass by value vs. pass by reference (to const)

在可以的情况下，尽量使用引用传递。

##### 不可以使用引用传递返回值的情况：

当返回值是函数中创建的变量时，不能传递该变量的引用作为返回值。

因为函数结束后，该变量会消失

## 5、友元（friend）函数

![image-20240318162505486](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240318162505486.png)

##### 动机：

private的变量被封装起来，不能直接读取。但是有一些函数需要直接读取数据，就用友元函数。

##### 示例：

图片下方，由于是友元函数，可以直接使用对象被封装起来的变量：`ths->re`和`ths->im`

## 6、相同class的各个objects互为友元(friends)

![image-20240318164313481](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240318164313481.png)

两个对象`c1`和`c2`从同一个class实例化而来，`c2`中的函数可以直接访问`c1`中封装的数据。

原因：相同class的各个objects互为友元(friends)。

# 小结：

1、数据放在private中

2、参数尽可能用引用传递，是否要加const看情况

3、返回值尽可能用引用传递

4、类的body中的函数，应该加const就加

5、构造函数尽量使用**成员初始化列表**

# 五、操作符重载与临时对象

## 1、操作符重载——成员函数

操作符也是一种函数，C++允许用户重载

![image-20240319102600752](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240319102600752.png)

##### this

- 代表当前对象的地址。它是一个指向当前对象的指针常量。
- 存在于每一个**非静态成员函数**中，可以在函数体里面使用，但是不能在参数中写出来，显示地作为参数传递给成员函数。(途中写出来只是为了方便理解)
- 静态成员函数不能使用this

## 2、return by reference 语法分析

![image-20240319104540756](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240319104540756.png)

传递者无需知道接受者是以**引用**形式接收。PS：接收端也可以通过by value方式接收。

- 图中最上方，this是一个指针，返回值为`*this`，为指针指向的对象，但是声明中的返回值是引用`complex&`。这也是正确的。

##### +=操作符的返回类型

为了让 `c3 += c2 += c1`合法，返回类型不能为void 

# 小结：类的声明部分结束，类的定义部分开始

![image-20240319111422949](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240319111422949.png)

上述所有内容均在类的声明中，即1中。下面的内容为类的定义，即2中。

2中有两种函数：

- 成员函数和非成员函数

## 3、操作符重载——非成员函数

![image-20240319111931426](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240319111931426.png)

## 4、临时对象 temp object

![image-20240319113503278](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240319113503278.png)

##### 使用`typename()`形式创建临时对象

- 途中三个函数return的值，右边标黄的部分，均为临时对象。
  - return 临时对象，不能使用引用返回。
- 临时对象的生命周期：下一行就消失。

## 5、<< 操作符的重载

![image-20240319121254508](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240319121254508.png)

##### 不能写为成员函数进行重载，只能写为全局函数。

原因：

其左操作数（即`cout`）必须是输出流对象(如std::ostream),而不是用户定义的类对象。

##### 返回类型不能改为void

若改为void，无法连串输出

# 小结：设计一个class要考虑的因素

![image-20240319121555390](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240319121555390.png)

1. 构造函数要使用**成员初始化列表**
2. 函数要考虑能否使用静态函数，尽量使用
3. 参数的传递，尽量考虑引用，同时考虑是否要加const
4. 参数的返回，尽量考虑引用
5. 数据尽量放在private，函数尽量放在public

# 七、三大函数：拷贝构造、拷贝赋值，析构

classes的两个分类：

- class里面有指针，比如`String`
  - 需要有三大函数，编译器默认给出的**拷贝构造**和**拷贝赋值**会造成内存泄漏
- class中无指针，比如`complex`
  - 不用自己写出三大函数，编译器会默认生成**拷贝构造**和**拷贝赋值**函数

## 1、字符串的设计：

![image-20240324160024303](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240324160024303.png)

![image-20240324161758241](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240324161758241.png)

## 2、带有指针的class没有写拷贝构造和拷贝赋值的后果(浅拷贝)

![image-20240324161434082](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240324161434082.png)

不写拷贝构造和拷贝赋值，编译器会默认生成这两个函数，**只会把指针拷贝过来，即浅拷贝**

- 如图所示，把字符串a赋值给b，a和b的指针指向同一个数据`Hello\0`,而b原来的指针所指向的数据`World\0`，没有指针指向它，即内存泄漏。
- 而`Hello\0`数据被两个String指向，其中一个String的内容改变，会引起另外一个也改变。

## 3、拷贝构造函数和拷贝赋值(深拷贝)

### 拷贝构造：

因为兄弟之间互为友元，直接取另一个对象的private data.

![image-20240324162819298](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240324162819298.png)

### 拷贝赋值:

1. 检测是否自我赋值，是的话直接return本身
2. 删除本身的数据
3. 创建新的空间
4. `strcpy`函数复制字符串

![image-20240324163240771](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240324163240771.png)

##### 是否一定要检测自我赋值？

检测自我赋值不止是为了提高效率，也是为了防止内存泄漏。若没有检测自我赋值，当自我赋值时，会进行第一步：先删除数据，当我们又要进行第二步访问数据时，产生了不确定行为。

![image-20240324163706711](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240324163706711.png)

# 八、堆、栈与内存管理

## 1、字符串的输出(<<操作符重载)

不能写为成员函数

![image-20240324215240127](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240324215240127.png)

## 2、堆、栈

![image-20240324215654272](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240324215654272.png)

##### 栈(stack)

存在于某作用域内的一块内存。

例如，

- 调用函数时传入函数的参数、函数的返回地址会被存在在栈中。局部对象也会被存放在栈中。
- 非函数，但用`{}`框起来的空间中的变量、对象等也存在放栈中。

##### 堆(Heap)

由操作系统取得的一块全局的空间。

- 可以在程序的任何地方以`new`的方式动态分配内存。
- 不再使用这块内存空间时需要手动释放

##### 全局/静态数据区( global/static data segment)

存储静态数据的内存区域，用于存放全局变量、静态变量以及静态常量等

## 3、stack objects 和static local object的生命期

##### 局部对象 stack object 

![image-20240325161635976](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240325161635976.png)

c1为local object或者auto object，在作用域结束时会自动调用析构函数。

- 存储在栈中。

##### 静态局部对象 static object 

![image-20240325161907269](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240325161907269.png)

c2为static object ,整个程序结束才会调用析构函数

- 存储位置既不在堆也不在栈，而是存储在程序的**全局数据区（global data segment）**中。

##### 全局对象 global object

![image-20240325162019086](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240325162019086.png)

c3为`global object`，生命在整个程序结束之后才结束。可以被认为是一种`static object`

- 存储位置为**全局数据区**

## 4、heap object的生命期

![image-20240325163258402](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240325163258402.png)

使用`new`创建`heap object`

- 生命期在delete之后结束。

- 若作用域结束，会让指针p消失，但是p所指向的内存仍没被释放，造成内存泄漏。

## 5、new 的原理

![image-20240325164244625](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240325164244625.png)

1. 分配内存
2. 转型
3. 调用构造函数

## 6、delete 的原理

![image-20240325164426274](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240325164426274.png)

1. 先调用析构函数，释放`ps`中m_data`指针指向的内容
2. 释放内存，释放ps本身指向的内容

##### 为什么析构函数里面是`delete[]`,释放ps用的是`delete`？

因为`String`中的构造函数用的是`new char[strlen(cstr)+1]`,使m_data指向一组对象，对应也要使用`delete[]`来删除一组对象。

## 7、动态分配(new)得到的内存具体形式

![image-20240325170305007](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240325170305007.png)

- 灰色的部分，调试模式存在
- 浅绿色部分，复数这个对象需要的内存
- 深绿色部分，填补内存，使其总大小为16的倍数
- 红色，记录了内存块的大小。
  - 十位的4表示一共有64个字节
  - 个位数的1表示获得这块内存。若为0表示把这块内存还给操作系统。

## 8、动态分配所得的数组

![image-20240325184634444](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240325184634444.png)

-  51：这块内存一共占80个字节，而且是操作系统分配给用户。
- 3：数组的大小
- 8*3：一个Complex占8个字节，一共有3个
- 32：调试所需的内存大小
- 4*2：cookie的大小
- 4：存储数组大小的内存的大小

## 9、array new 一定要搭配array delete，即new[]一定要搭配delete[]

![image-20240325201859448](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240325201859448.png)

- delete[] 会调用三次析构函数

- 如果用delete，只会调用一次析构函数，造成后面两个String的内存泄漏。

# 十、扩展补充

## 1、静态 static

![image-20240401135812192](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240401135812192.png)

不加`static`的情况

- `c1.real()`会传递一个this pointer
- 右下角，成员函数都有一个隐藏的参数：`this pointer`，不能写在参数中，但是在函数体中可写可不写(黄色高亮部分)，不写的话编译器会自动加上。

加了`static`的情况

- 与对象脱离。
- 静态函数
  - 没有this pointer。
  - 不能访问，存取对象的变量
  - 只能访问、存取静态的变量

![image-20240401140446441](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240401140446441.png)

- 类中的静态变量
  - `static double m_rate`:静态变量的声明
  - `double Account::m_rate = 8.0`:
    - **静态变量一定要在类的外面进行定义（或者说初始化）！！！！**
    - 可以不给值
- 调用静态函数的两种方法
  - 可以直接通过对象调用:`a.set_rate(7.0)`
    - 注意，区别于非静态函数，这里不会传递this pointer
  - 可以直接通过类名调用：`Account::set_rate(5.0)`

## 2、private中的构造函数(即Singleton设计模式)

![image-20240401141140850](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240401141140850.png)

##### 使用场景：

写的class只希望有一个实例化对象。

##### 上述写法的缺陷：

若没有人需要A，它的实例化对象a仍然存在，比较浪费

##### 更好的写法（即Meyers Singleton）：

![image-20240401141539668](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240401141539668.png)

在类的外面定义`getInstance`，其中包含了静态对象a的实例化。

- 只有在调用`getInstance()`时，`a`才会被创建
- 在`getInstance()`结束时，`a`仍然存在

## 3、cout

![image-20240401142539119](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240401142539119.png)

cout就是一种ostream，操作符`<<`的重载很多，所以能接受不同类型的数据并打印出来

## 4、模板

### 4.1、类模板

![image-20240401142647380](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240401142647380.png)

`complex<double>`会把`T`全部替换成`double`

### 4.2、函数模板

![image-20240401143113592](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240401143113592.png)

##### 与类模板最大区别：

- `r3 = min(r1, r2);` 
  - 不用绑定特定的类别
  - 编译器会自动**实参推导（argument deduction）**，得到`T`的类型
- 而类模板需要手动指定类型 (`double`, `int`)
  - `complex<double> c1(2.5, 1.5);`

##### 编译流程：

1. 从`r3 = min(r1, r2);`进行实参推导，将`min`定义中的`T`替换为`stone`类
2. `return b < a ? b : a;`可知，`stone`的实例化对象`b`调用 操作符 `<`
3. 从`class stone`的定义中得到， 操作符`<`在stone类中的重载定义 
   - 如果class中没有 < 的重载，编译器会报错。

## 5、namespace

![image-20240401144450714](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240401144450714.png)

##### 动机：为了避免同一个项目中，不同的人变量命名冲突。

##### 三种方式：

- `Using Directive`(使用指令)
  - 使用形式举例
    - `using namespace std`
  - 将命名空间中的所有成员引入当前作用域
- `Using Declaration`(使用声明)
  - 使用形式举例
    - `using std::cout`
  - 将命名空间中的特定成员引入当前作用域
    - `cout` 可以直接使用，但是其他成员需要使用**限定符**，如，`std:cin`

## 其他

![image-20240401145216142](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240401145216142.png)
