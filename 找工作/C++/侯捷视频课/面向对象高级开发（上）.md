# 视频地址：

- c++11新特性：

  https://www.youtube.com/watch?v=TJIb9TGfDIw&list=PL-X74YXt4LVYo_bk-jHMV5T3LHRYRbZoH

  https://www.youtube.com/watch?v=8jO1e6l7IGc&list=PLH_SiDrNHIUTzLKsNW-ZSDX4Oj3uECg64

- c++内存管理机制

  https://www.youtube.com/watch?v=0ymWCS1E8t4&list=PLH_SiDrNHIUTQM_ZPqI4b8as35_5rJWjS

- std标准库与泛型编程

  https://www.youtube.com/watch?v=SLcWLz1mgow&list=PLH_SiDrNHIUS8wBdEIxoAXag5r2Ju-lq_

- **面向对象高级高级开发(上)**

  https://www.youtube.com/watch?v=ETkCNquiAiw&list=PL1S6aIjFDLHTsycQuMgdBVC3fEwzxsbT1

- C++ start up 揭秘：C++程序的生前死后

  https://www.youtube.com/watch?v=_b5yzeXwMfY&list=PLH_SiDrNHIURCCENYhmaF3SVbARiom7Oc

# 二、头文件与类的声明

## 1、头文件中的防卫式声明

![image-20240317011302793](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240317011302793.png)

##### 动机：

当工程很大的时候，我们可能会重复`include`同一个头文件。防卫式声明使得头文件被多次被`include`时，只有第一次生效。

##### 具体语法

- `#ifndef __COMPLEX__`

  如果之前如果没有定义过 `COMPLEX`

- `#define __COMPLEX__`

  那么就定义`__COMPLEX__`

## 2、class的声明

![image-20240317012616822](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240317012616822.png)

##### 前置声明（forward declarations）

##### 类声明（class declarations）

- class head
- class body

##### 类定义（class definitoin） 

##### 举例：复数的声明

![image-20240317013503382](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240317013503382.png)

## 3、模板

##### 动机：

声明class的时候不确定变量的类型，可以先用模板

##### 示例：

![image-20240317014026388](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240317014026388.png)

声明复数类的时候，不确定实部和虚部的类型，使用模板。

# 三、构造函数

## 1、内联函数

![image-20240317013503382](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240317013503382.png)

- 函数可以在class body中定义，称为内联函数

  ```cpp
  double real () const { return re; }
  double imag () const { return im; }
  ```

  - 可以将所有函数的定义都写在类的声明中，但是最终是否为内联函数，由编译器决定。太复杂的函数不能称为内联函数。

- 也可以只在这声明，在body之外定义

  ```cpp
  complex& operator += (const complex&) ;
  ```

​	

## 2、访问级别

##### public

公开可见

函数，如果要被外界调用，则放在public

##### private

私人可见，创建的对象不能直接调用相关的参数

一般是数据变量

## 3、构造函数

![image-20240317174921085](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240317174921085.png)

- 没有返回类型
- 与类名同名
- 赋值方式
  - 推荐使用初始列赋值，这种写法只有构造函数有。
  - 也可以在函数体里赋值，但是不推荐。即图片右上角的方法。

##### 析构函数

不带指针的类大部分不用写

## 4、重载 overloading

一个以上的相同名称的函数

![image-20240317180008848](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240317180008848.png)

- ```cpp
  double real () const {return re}
  ```

  返回实部

- ```cpp
  double real (double r) { re = r;}
  ```

  给实部赋值

- real函数编译后，编译器会根据参数数量、参数的类型，编码出不同的名称

##### 不能使用重载的情况

图中黄色部分，不能使用

当我们执行

```cpp
complex c1；
```

或

```cpp
complex c2();
```

两个构造函数都有默认值，都可以被调用，编译器不知道调用哪个，所以不能使用黄色部分

# 四、参数传递与返回值

## 1、将构造函数放在private中：Singleton设计模式

![image-20240318130504235](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240318130504235.png)

##### 动机：

Singleton 模式保证一个类只有一个实例存在。

## 2、常量成员函数

![image-20240318131444117](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240318131444117.png)

##### 动机：

不改变数据的成员函数，要使用`const`。例如：只读取相关的数据。

##### const出现的位置：

- 成员函数

  出现在小括号的后面，大括号的前面

- 对象或者变量

  出现在前面，表明对象或者变量的内容不可改变

##### 该使用const但没使用后果：

```cpp
double real () { return re; }
```

```cpp
{
	const complex c1(2,1);
	cout << c1.real();
}
```

c1为静态对象，数据不可更改，但c1.real()没加const，编译器认为该函数可以改变数据，因此调用该函数会报错。

## 3、参数传递：pass by value vs. pass by reference (to const)

![image-20240318133856394](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240318133856394.png)

##### 传递值：

直接将值打包传递到函数的堆栈中，占用的字节可能会很大，不推荐

##### 传递引用：

只传递数据的地址，占用的字节就是地址的大小，速度很快

函数中的参数尽量都使用这种写法。

##### 传递静态引用：

传递引用，函数对于参数的修改会影响到原来的数据。

如果不希望函数修改参数的值，传递静态引用

## 4、返回值传递：pass by value vs. pass by reference (to const)

在可以的情况下，尽量使用引用传递。

##### 不可以使用引用传递返回值的情况：

当返回值是函数中创建的变量时，不能传递该变量的引用作为返回值。

因为函数结束后，该变量会消失

## 5、友元（friend）函数

![image-20240318162505486](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240318162505486.png)

##### 动机：

private的变量被封装起来，不能直接读取。但是有一些函数需要直接读取数据，就用友元函数。

##### 示例：

图片下方，由于是友元函数，可以直接使用对象被封装起来的变量：`ths->re`和`ths->im`

## 6、相同class的各个objects互为友元(friends)

![image-20240318164313481](https://raw.githubusercontent.com/letMeEmoForAWhile/typoraImage/main/img/image-20240318164313481.png)

两个对象`c1`和`c2`从同一个class实例化而来，`c2`中的函数可以直接访问`c1`中封装的数据。

原因：相同class的各个objects互为友元(friends)。

# 小结：

1、数据放在private中

2、参数尽可能用引用传递，是否要加const看情况

3、返回值尽可能用引用传递

4、类的body中的函数，应该加const就加

5、构造函数尽量使用 初始化值

# 五、操作符重载
